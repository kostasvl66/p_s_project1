# Άσκηση 1.3

### Περιγραφή προβλήματος
Το πρόβλημα βρίσκεται στην σωστή ενημέρωση των μεταβλητών του `array_stats` χωρίς ζητήματα συγχρονισμού, και στην πιθανή βελτίωση της ταχύτητας του παράλληλου αλγορίθμου.

### Περιγραφή λύσης
Για την οργάνωση της λύσης, αρχικά ορίζονται οι βοηθητικές συναρτήσεις:
- `parse_args()`: Διαβάζει τα command line arguments με κατάλληλους ελέγχους
- `elapsed()`: Επιστρέφει την χρονική διαφορά σε δευτερόλεπτα (έως ακρίβεια nsec) από το start στο end. Σημειώνεται ότι για τις χρονικές μετρήσεις χρησιμοποιείται η δομή struct timespec της *C11*.

Για ευελιξία τα 4 arrays έχουν οριστεί ως `int *arrays[4];` globally. Για την διαχείριση των arrays ορίζονται οι συναρτήσεις:
- `allocate_arrays()`: Δεσμεύει τα arrays.
- `free_arrays()`: Αποδεσμεύει τα arrays.
- `assign_random_values()`: Θέτει τυχαίες τιμές σύμφωνα με την εκφώνηση.
- `array_stats_equals()`: Ελέγχει ισότητα μεταξύ δύο `array_stats_s`, το οποίο χρησιμεύει για έλεγχο συνέπειας των αποτελεσμάτων του σειριακού και του παράλληλου αλγορίθμου.
- `print_array_stats()`: Τυπώνει τα stats, για λόγους debugging.
- `count_non_zero_serial()`: Ο σειριακός αλγόριθμος καταμέτρησης των μη μηδενικών στοιχείών.
- `count_non_zero_worker()`: Η συνάρτηση που εκτελούν τα threads για τον παράλληλο αλγόριθμο, ο οποίος είναι ενσωματωμένος στην `main()`.

Η `main()`, για τον παράλληλο αλγόριθμο απλώς κάνει τις κατάλληλες αρχικοποιήσεις και δημιουργεί τα threads, στα οποία αναθέτει την `count_non_zero_worker()`, με όρισμα τον αριθμό "rank" του κάθε νήματος.

Η `count_non_zero_worker()`, σύμφωνα με το νήμα που την εκτελεί, απλώς αποφασίζει ποιο μέλος του `array_stats` πρέπει να ενημερώσει, κάνει την καταμέτρηση, και κατευθείαν γράφει το κατάλληλο πεδίο. Δεν τίθεται ζήτημα συγχρονισμού επειδή εξ ορισμού το κάθε νήμα γράφει στο δικό του "τμήμα" του `array_stats`, το οποίο αν και είναι "μία" μεταβλητή, περιέχει πολλά bytes, και το κάθε νήμα ποτέ δεν τροποποιεί τα bytes ενός άλλου νήματος. Δηλαδή δεν υπάρχει συνθήκη ανταγωνισμού, και δεν υπάρχει λόγος για χρήση mutex  ή άλλης δομής συγχρονισμού.

Για επιπλέον **επιτάχυνση** της παράλληλης εκτέλεσης, παρατηρούμε ότι η δομή `array_stats_s` έχει πιθανότατα μέγεθος `4 * sizeof(long long)`, το οποίο πιθανότατα είναι μικρότερο από 64 bytes. Υποθέτοντας ότι τα cache lines του συστήματος έχουν μέγεθος  64 bytes,  είναι λογικό μία τέτοια δομή να περιέχεται εξ ολοκλήρου μέσα σε ένα τέτοιο cache line. Εφόσον τα διαφορετικά threads συνεχώς γράφουν στο ίδιο cache line, είναι φανερό ότι υπάρχει **false sharing**. Για την αντιμετώπιση του false sharing θα πρέπει τα `info_array_0`, `info_array_1`, κτλ. να τοποθετούνται σε διαφορετικά cache lines. Για να γίνει αυτό στον κώδικα, γίνεται χρήση του `alignas()` (*C11*), το οποίο εφαρμόζεται τόσο στην δομή `array_stats_s` όσο και στα πεδία της ξεχωριστά, και απαιτεί το alignment να γίνει στα 64 bytes, όπως έχει οριστεί στον κώδικα. Δηλαδή αναγκάζει τον compiler να τοποθετήσει αρκετό padding ανάμεσα στα πεδία, αλλά και ευθυγραμμίζει την αρχή του `array_stats_s` με την αρχή ενός cache line. Αυτό (εφόσον η υπόθεση για το cache line = 64 bytes είναι σωστή για το σύστημα), αποφεύγει προβλήματα false sharing στην συγκεκριμένη δομή. Όπως φαίνεται και πιο κάτω, αυτή η αλλαγή επιταχύνει (ελαφρώς) την παράλληλη εκτέλεση.

Σημειώνεται ότι στον κώδικα η δομή `array_stats_s` ορίζεται είτε με τον αρχικό είτε με τον βελτιωμένο τρόπο με την χρήση του preprocessor. Αν έχει οριστεί τo `#define BETTER 1`, τότε ορίζεται η βελτιωμένη εκδοχή, αλλιώς αν έχει οριστεί `#define BETTER 0` ορίζεται η αρχική εκδοχή. Ο ορισμός του `BETTER` μπορεί να γίνει στο compilation, όπως φαίνεται και στο σχετικό *Makefile*.

### Πειραματικά αποτελέσματα
- **N**: Το μέγεθος των 4 arrays.
- Σε όλα τα παρακάτω αποτελέσματα οι χρόνοι είναι σε *seconds* και δίνεται ακρίβεια *microsecond*.
- Κάθε αποτέλεσμα πειράματος (δηλαδή εκτέλεσης με συγκεκριμένες εισόδους) είναι μέσος όρος 4 διαδοχικών εκτελέσεων.

Χρόνοι εκτέλεσης σειριακού και 4-threaded αλγοριθμου για δεδομένο N, **με false sharing**.
|Ν\Execution |**Serial**|**4 threads**|
|------------|----------|-------------|
|**100000**  |0.000451  |0.000493     |
|**1000000** |0.004437  |0.003290     |
|**10000000**|0.043330  |0.024301     |

*Speedup* και *Efficiency* σε αντιστοιχία με τον παραπάνω πίνακα, **με false sharing**.
|Ν\Metrics   |**Speedup**|**Efficiency**|
|------------|-----------|--------------|
|**100000**  |0.916286   |0.229072      |
|**1000000** |1.348632   |0.337158      |
|**10000000**|1.783046   |0.445762      |

Χρόνοι εκτέλεσης σειριακού και 4-threaded αλγοριθμου για δεδομένο N, **χωρίς false sharing**.
|Ν\Execution |**Serial**|**4 threads**|
|------------|----------|-------------|
|**100000**  |0.000475  |0.000511     |
|**1000000** |0.004749  |0.002721     |
|**10000000**|0.048036  |0.020185     |

*Speedup* και *Efficiency* σε αντιστοιχία με τον παραπάνω πίνακα, **χωρίς false sharing**.
|Ν\Metrics   |**Speedup**|**Efficiency**|
|------------|-----------|--------------|
|**100000**  |0.930005   |0.232501      |
|**1000000** |1.745475   |0.436369      |
|**10000000**|2.379834   |0.594958      |

### Σχολιασμός αποτελεσμάτων
Από τους παραπάνω πίνακες συμπεραίνουμε τα εξής:
- Από την χρήση πολύ μεγάλων *N* είναι φανερό ότι για να εμφανιστεί επιτάχυνση το συγκεκριμένο πρόβλημα απαιτεί μεγάλα *N*. Συγκεκριμένα, η επιτάχυνση ξεκινάει σε κάθε περίπτωση περιπου στο *N*=1000000, ενώ για μικρότερα *N* υπάρχει μικρή επιβράδυνση. Από *Ν*=10^6 σε *Ν*=10^7 η επιτάχυνση έχει αύξηση, αλλά αυτή η αύξηση δεν είναι μεγάλη.
- Και στις δύο περιπτώσεις (με και χωρίς false sharing), οι αποδοτικότητες σε σχέση με τα 4 νήματα είναι αρκετά μικρές, αν και με την αποφυγή του false sharing η αποδοτικότητες είναι λίγο μεγαλύτερες.
- Γενικά μεταξύ των εκτελέσεων με και χωρίς false sharing, παρατηρείται μια αρκετά συνεπής αύξηση στην επιτάχυνση, χωρίς όμως αυτή η αύξηση να είναι πολύ μεγάλη.
- Με την αποφυγή του false sharing, στο μέγιστο δεδομένο *N* οι μετρήσεις πλησιάζουν την αναμενόμενη συμπεριφορά, και πιθανότατα για ακόμα μεγαλύτερα *N* που δεν φαίνονται στον πίνακα, η αποδοτικότητα θα συνεχίζει να αυξάνεται.

Για τα πειράματα χρησιμοποιήθηκε σύστημα με τα εξής χαρακτηριστικά:
- **Μοντέλο laptop:** MSI Katana GF66 12UC
- **Μοντέλο CPU:** 12th Gen Intel(R) Core(TM) i7-12650H
- **Logical processors:** 16
- **OS:** WSL2 (Ubuntu) πάνω σε Windows11
- **C compiler:** gcc (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0

**Σημείωση:** Η hardware μνήμη RAM είναι 16GB όμως το WSL την περιορίζει σε ~8GB. Παρόλα αυτά **τονίζεται ότι το WSL δεν περιορίζει την χρήση των hardware threads**. 

Το πρόγραμμα της άσκησης εκτελείται με σωστό τρόπο στα συστήματα linux του εργαστηρίου.
