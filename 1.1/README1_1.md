# Άσκηση 1.1
**Υλοποίηση:** Εμμανουήλ-Ταξιάρχης Οζίνης (sdi2300147)

### Περιγραφή προβλήματος
Το πρόβλημα μπορεί να χωριστεί στα εξής σημαντικά υποπροβλήματα:
- Την διατύπωση και υλοποίηση του σειριακού αλγορίθμου για πολλαπλασιασμό πολυωνύμων.
- Την **παραλληλοποίηση** του αλγορίθμου σε ικανοποιητικό βαθμό, δηλαδή με τέτοιο τρόπο που το παράλληλο τμήμα του είναι σημαντικά μεγαλύτερο από το μη παραλληλοποιημένο.

### Περιγραφή λύσης
Για την οργάνωση της λύσης, αρχικά ορίζονται οι βοηθητικές συναρτήσεις:
- `parse_args()`: Διαβάζει τα command line arguments με κατάλληλους ελέγχους
- `elapsed()`: Επιστρέφει την χρονική διαφορά σε δευτερόλεπτα (έως ακρίβεια nsec) από το start στο end. Σημειώνεται ότι για τις χρονικές μετρήσεις χρησιμοποιείται η δομή struct timespec της *C11*.
- `generate_random_coef()`: Δίνει τυχαίες μη μηδενικές ακέραιες τιμές σε ένα πολυωνυμο, όπου ο κάθε συντελεστής έχει απόλυτη τιμή το πολύ `MAX_ABS_COEFFICIENT_VALUE`.

Έχει οριστεί δομή `Polynomial` και για την διαχείρησή της υπάρχουν οι ακόλουθες συναρτήσεις:
- `pol_init()`: Δεσμεύει δομή Polynomial χρησιμοποιώντας  ήδη δεσμευμένους συντελεστές.
- `pol_destroy()`:  Αποδεσμεύει το πολυώνυμο και τους συντελεστές.
- `pol_print()`: Τυπώνει ένα πολυώνυμο, για λόγους debugging
- `pol_equals()`: Ελέγχει αν δύο πολυώνυμα είναι ίσα.
- `pol_add()`: Προσθέτει δύο πολυώνυμα. Τα πολυώνυμα και το αποτέλεσμα πρέπει να είναι ήδη δεσμευμένα. Αυτό γίνεται για λόγους ταχύτητας στον πολλαπλασιασμό.
- `pol_multiply()`: Ο σειριακός αλγόριθμος πολλαπλασιασμού πολυωνύμων. Δεσμεύει ο ίδιος το αποτέλεσμα. Η υλοποίησή του επεξηγείται αργότερα.
- `pol_multiply_threaded()`: Ο παραλληλοποιημένος αλγόριθμος πολλαπλασιασμού. Είναι υπεύθυνος για την δημιουργία και "συλλογή" των νημάτων. Καλείται κατευθείαν από την `main()` και δεσμεύει ο ίδιος το αποτέλεσμα. Η υλοποίησή του επεξηγείται αργότερα.


Για την υλοποίηση του σειριακού αλγορίθμου, έχει γίνει η εξής προσέγγιση:
Έστω ότι πολλαπλασιάζονται τα `pol1` και `pol2`. Τότε, διατηρώντας ένα άθροισμα αρχικοποιημένο σε 0, **για κάθε όρο** του `pol1` πολλαπλασιάζουμε αυτό τον όρο με **ολόκληρο** το `pol2`, πολλαπλασιάζοντας ή μηδενίζοντας τους κατάλληλους συντελεστές και προσαρμόζοντας τις δυνάμεις. Στο τέλος κάθε επανάληψης προσθέτουμε το προσωρινό αποτέλεσμα στο άθροισμα. Έτσι στο τέλος του αλγορίθμου το άθροισμα είναι το αποτέλεσμα του πολλαπλασιασμού.

Για την **παραλληλοποίηση** του σειριακού αλγορίθμου έχει γίνει η εξής προσέγγιση: Παρατηρείται ότι ο σειριακός αλγόριθμος αποτελείται από δύο εμφωλευμένους βρόχους. Η παραλληλοποίηση επιλέχθηκε να γίνει στον εξωτερικό βρόχο επειδή έτσι το μοναδικό κρίσιμο σημείο είναι η πρόσθεση πολυωνύμων και η εγγραφή στην κοινόχρηστη μεταβλητή του αθροίσματος. Αυτό επίσης μπορεί να βελτιωθεί αν οι προσθέσεις των "τοπικών" επαναλήψεων γίνουν σε τοπικά αθροίσματα για κάθε νήμα, και το κρίσιμο σημείο περιλαμβάνει μόνο μία πρόσθεση πολυωνύμων. Ο λόγος που δεν επιλέχθηκε ο εσωτερικός βρόχος για παραλληλοποίηση είναι ότι εκτός της επιμέρους παραλληλοποίησης και της πρόσθεσης, θα  απαιτούνταν **φράγματα** πριν και μετά τον αλγόριθμο της πρόσθεσης. Αυτό θα γινόταν γιατί το τμήμα κώδικα που πολλαπλασιάζει έναν όρο με ένα πολυώνυμο έχει διαφορετικό αριθμό επαναλήψεων από αυτές της πρόσθεσης, πράγμα που σημαίνει ότι (για την πλήρη αξιοποίηση των δεδομένων νημάτων) ο διαμοιρασμός τους θα γινόταν με διαφορετικά νήματα να χρησιμοποιούν αποτελέσματα άλλων νημάτων, το οποίο χωρίς φράγματα θα εμφάνιζε συνθήκες ανταγωνισμού.

Η συνάρτηση `pol_multiply_threaded()` χρησιμοποιεί επιπλέον βοηθητικές συναρτήσεις. Από αυτές σημαντικότερη είναι αυτή που εκτελούν τα νήματα: `calc_prod_i_worker()`. Επειδή τα threads δημιουργούνται από την `pol_multiply_threaded()` και όχι την `main()`, οι διαμοιραζόμενες μεταβλητές για τα νήματα δεν ταυτίζονται με τις global, αλλά (στην περίπτωση των πολυωνύμων) είναι pointers, οι οποίοι μαζί με άλλα "private" δεδομένα περνώνται στην `calc_prod_i_worker()` μέσω της δομής `WorkerParams`.

Στην συνάρτηση `calc_prod_i_worker()`, για να γίνει η πρόσθεση του τοπικού αθροίσματος κάθε νήματος στο διαμοιραζόμενο συνολικό άθροισμα, χρησιμοποιείται ένα **mutex**. Με την χρήση του εξασφαλίζεται ο σωστός συγχρονισμός των νημάτων έτσι ώστε να μην υπάρχουν συνθήκες ανταγωνισμού σε διαμοιραζόμενα δεδομένα. Σε πολλές περιπτώσεις, στον αλγόριθμο τα νήματα γράφουν σε "κοινούς" πίνακες. Όμως τότε δεν χρειάζεται συγχρονισμός γιατί οι πίνακες αυτοί έχουν ξεχωριστές θέσεις για κάθε νήμα και άρα στην πράξη κάθε νήμα ποτέ δεν προσπαθεί να γράψει σε θέση που δεν του ανήκει. 

Σημειώνεται ότι στην συνάρτηση `pol_multiply_threaded()` γίνονται στην αρχή αρκετές δεσμεύσεις μνήμης (με κατάλληλες αποδεσμεύσεις και ελέγχους), έτσι ώστε να αποφευχθούν όσο το δυνατότερο δεσμεύσεις μέσα σε βρόχους του αλγορίθμου. Ωστόσο αυτές οι δεσμεύσεις θεωρούνται τμήμα του αλγορίθμου όσον αφορά τις μετρήσεις, επειδή ο σειριακός αλγόριθμος δεν έχει κατι αντίστοιχο, και επομένως αυτό πρέπει να θεωρηθεί overhead του παράλληλου αλγορίθμου. Στην πράξη αυτές οι δεσμεύσεις προκύπτει ότι είναι τάξης μικρότερης του 1 *μs*.

### Πειραματικά αποτελέσματα
- **N**: Βαθμός των πολυωνύμων
- **Threads**: Αριθμός νημάτων στον παράλληλο αλγόριθμο
- Σε όλα τα παρακάτω αποτελέσματα οι χρόνοι είναι σε *seconds* και δίνεται ακρίβεια *microsecond*.
- Αποφεύγεται η χρήση του N = *10^6* γιατί στο συγκεκριμένο σύστημα μια τέτοια εκτέλεση ολοκληρώνεται σε μη πρακτικό αριθμό λεπτών, καθώς η πολυπλοκότητα είναι τετραγωνική.
- Κάθε αποτέλεσμα πειράματος (δηλαδή εκτέλεσης με συγκεκριμένες εισόδους) είναι μέσος όρος 4 διαδοχικών εκτελέσεων.
 
Σειριακοί χρόνοι εκτέλεσης για κάθε πείραμα με συγκεκριμένο N και Threads.
|**N\Threads**|**1**   |**2**   |**4**   |**8**   |**16**  |
|-------------|--------|--------|--------|--------|--------|
|**1000**     |0.000953|0.000850|0.000867|0.000870|0.000865|
|**10000**    |0.091780|0.090150|0.090316|0.092148|0.089413|
|**100000**   |9.436521|9.435455|9.341023|9.505993|9.306726|

Παράλληλοι χρόνοι εκτέλεσης για κάθε πείραμα με συγκεκριμένο N και Threads, σε αντιστοιχία με τον παραπάνω πίνακα.
|**N\Threads**|**1**   |**2**   |**4**   |**8**   |**16**  |
|-------------|--------|--------|--------|--------|--------|
|**1000**     |0.001006|0.000651|0.000657|0.000783|0.001066|
|**10000**    |0.082964|0.043477|0.028604|0.025747|0.020296|
|**100000**   |8.423622|4.141602|2.362285|1.482740|1.303185|

*Speedup* παράλληλης εκτέλεσης σε σχέση με την σειριακή, σε αντιστοιχία με τους παραπάνω πίνακες.
|**N\Threads**|**1**   |**2**   |**4**   |**8**   |**16**  |
|-------------|--------|--------|--------|--------|--------|
|**1000**     |0.947342|1.304682|1.318752|1.111821|0.810830|
|**10000**    |1.106257|2.073504|3.157497|3.578970|4.405420|
|**100000**   |1.120245|2.278214|3.954231|6.411099|7.141523|

*Efficiency* σε σχέση με το *speed up* και τον αριθμό των νημάτων, σε αντιστοιχία με τους παραπάνω πινακες.
|**N\Threads**|**1**   |**2**   |**4**   |**8**   |**16**  |
|-------------|--------|--------|--------|--------|--------|
|**1000**     |0.947342|0.652341|0.329688|0.138977|0.050676|
|**10000**    |1.106257|1.036752|0.789374|0.447371|0.275338|
|**100000**   |1.120245|1.139107|0.988557|0.801387|0.446345|

### Σχολιασμός αποτελεσμάτων
Από τους παραπάνω πίνακες συμπεραίνουμε τα εξής:
- Γενικά  υπάρχει αισθητή επιτάχυνση, η οποία είναι πολύ σημαντικότερη για μεγαλύτερες τιμές του *Ν*. Για *N*=1000 για παράδειγμα, η επιτάχυνση είναι χαμηλότερη από 1.5, ενώ για *N*=10000 είναι ήδη κοντά στο 3 κατά μέσο όρο.
- Μέχρι και τα 4-8 νήματα η επιτάχυνση είναι αρκετά αποδοτική, ενώ στα 16 παρατηρούμε ότι η αποδοτικότητα είναι ελάχιστη. Αυτό προφανώς συμβαίνει επειδή το μέγεθος των δεδομένων δεν είναι αρκετά μεγάλο για την πραγματική αξιοποίηση 16 νημάτων. Πιθανότατα, για αρκετά μεγαλύτερα *Ν* (τα οποία δεν παρατίθονται για λόγους ταχύτητας), η αποδοτικότητα των 16 νημάτων θα αυξανόταν.
- Για 1 και 2 νήματα παρατηρούμε μερικές αποδοτικότητες λίγο μεγαλύτερες του 1, το οποίο στην θεωρία δεν θα έπρεπε να συμβαίνει. Εφόσον οι αλγόριθμοι έχουν ο καθένας διαφορετικά overheads, αλλά και διαφορετική χρήση της μνήμης (ίσως και της cache), είναι ίσως λογικό (για σχετικα μεγάλα *Ν*) να υπάρχει λίγος θόρυβος, που έχει αυτό το αποτέλεσμα.

Για τα πειράματα χρησιμοποιήθηκε σύστημα με τα εξής χαρακτηριστικά:
- **Μοντέλο laptop:** MSI Katana GF66 12UC
- **Μοντέλο CPU:** 12th Gen Intel(R) Core(TM) i7-12650H
- **Logical processors:** 16
- **OS:** WSL2 (Ubuntu) πάνω σε Windows11
- **C compiler:** gcc (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0

**Σημείωση:** Η hardware μνήμη RAM είναι 16GB όμως το WSL την περιορίζει σε ~8GB. Παρόλα αυτά **τονίζεται ότι το WSL δεν περιορίζει την χρήση των hardware threads**. 

Το πρόγραμμα της άσκησης εκτελείται με σωστό τρόπο στα συστήματα linux του εργαστηρίου.
