# Άσκηση 1.5
**Υλοποίηση:**\
Εμμανουήλ-Ταξιάρχης Οζίνης (sdi2300147) και Κωνσταντίνος Γεώργιος Βλαζάκης (sdi2300017)

### Περιγραφή προβλήματος
Το πρόβλημα βρίσκεται στην σωστή υλοποίηση της λειτουργίας ενός φράγματος σε κάθε υποερώτημα, έτσι ώστε με συνεπή τρόπο, όλα τα νήματα να βρίσκονται πάντα στην ίδια επανάληψη του αντίστοιχου βρόχου.

### Περιγραφή λύσης
Και στα 3 ερωτήματα, έχουν οριστεί οι ακόλουθες βοηθητικές συναρτήσεις:
- `parse_args()`: Διαβάζει τα ορίσματα της εντολής με τους κατάλληλους ελέγχους και ενημερώνει τις global μεταβλητές.
- `elapsed()`: Επιστρέφει την χρονική διαφορά σε δευτερόλεπτα (έως ακρίβεια nsec) από το start στο end. Σημειώνεται ότι για τις χρονικές μετρήσεις χρησιμοποιείται η δομή struct timespec της *C11*.

Και στα τρία ερωτήματα ακολουθείται η ίδια δομή της `main()`, η οποία δημιουργεί και εκκινεί τα threads, αναθέτοντας στο καθένα την εκτέλεση της `loop_worker()`.

#### Ερώτημα (i) - barrier_q1.c
Για το πρώτο ερώτημα, γίνεται χρήση του ήδη υλοποιημένου φράγματος POSIX. Δηλαδή μέσα στο βρόχο του κάθε νήματος γίνεται απλώς η κλήση:
```c
// POSIX implementation of barrier wait
pthread_barrier_wait(&barrier);
```
Επίσης στην `main()` γίνεται ένα σχετικό `pthread_barrier_init()` και `pthread_barrier_destroy()`.

#### Ερώτημα (ii) - barrier_q2.c
Για το δεύτερο ερώτημα, όπως ζητείται και στην εκφώνηση χρησιμοποιείται η υλοποίηση φράγματος με mutex και μεταβλητή συνθήκης που έχει αναφερθεί στο μάθημα.

Ο κώδικας του φράγματος περικλείεται μέσα σε ένα mutex, έτσι ώστε να μόνο ένα νήμα την φορά ενημερώνει την κατάσταση του φράγματος. Χρησιμοποιείται μεταβλητή `waiting_thread_count`, η οποία μετρά τα νήματα που έχουν ήδη φτάσει το φράγμα και περιμένουν να προχωρήσουν. Αν ένα νήμα που εκτελεί τον κώδικα του φράγματος δεν βρει **όλα τα υπόλοιπα** να περιμένουν, τότε και αυτό πρέπει να περιμένει. Διαφορετικά, το τελευταίο νήμα που φτάνει στο φράγμα "ξυπνά" όλα τα υπόλοιπα νήματα, και όλα μαζί (ιδανικά) συνεχίζουν μετά το φράγμα.

#### Ερώτημα (iii) - barrier_q3.c
Για το τρίτο ερώτημα, με βάση τις απαιτήσεις της εκφώνησης, χρησιμοποιείται υλοποίση φράγματος "Sense-reversal centralized barrier".

Ορίζεται το **struct srcBarrier barrier**, το οποίο αποτελεί την δομή που αναπαριστά τον φραγμό, με τα παρακάτω μέρη:
    - **int max\_barred\_threads**: Το μέγιστο όριο νημάτων που πρέπει να φτάσουν στον φραγμό για να "σηκωθεί". Αρχικοποιείται με την τιμή **4** στο `main`, ανεξάρτητα από το `THREAD_COUNT`.
    - **int total\_threads\_barred**: Μετρητής που κρατά τον αριθμό των νημάτων που έχουν φτάσει ήδη στον φραγμό.
    - **pthread\_mutex\_t lock**: Ένα κλείδωμα αμοιβαίου αποκλεισμού (mutex) που προστατεύει την πρόσβαση και την τροποποίηση των κοινόχρηστων πεδίων (`total_threads_barred` και `sense_flag`) μέσα στη συνάρτηση `srcBarrier_wait`.
    - **bool sense\_flag**: Η σημαία "αίσθησης" (sense flag) του φραγμού, η οποία αντιστρέφεται όταν ο φραγμός απελευθερώνεται.

Οι αναγκαίες συναρτήσεις για την υλοποίηση είναι:
- **srcBarrier\_init**:
    - Λειτουργία: Αρχικοποιεί τη δομή φραγμού.
    - Αρχικοποιεί το `mutex` με την `pthread_mutex_init`.
    - Ορίζει το `max_barred_threads` (το όριο του φραγμού).
    - Θέτει το `total_threads_barred` σε 0 και το `sense_flag` σε `false`.

- **srcBarrier\_wait**:
    - Λειτουργία: Η κεντρική συνάρτηση που επιβάλλει τον συγχρονισμό του φραγμού.
    - Τοπικές μεταβλητές: Κάθε νήμα χρησιμοποιεί μια τοπική μεταβλητή `private_sense` ίση με την τρέχουσα τιμή της καθολικής `barrier->sense_flag`.
    - **CRITICAL SECTION**:
        - Κλειδώνει το `mutex` (`pthread_mutex_lock`).
        - Αυξάνει τον μετρητή των νημάτων που έχουν φτάσει (`total_threads_barred++`).
        - Αντιστρέφει την τοπική σημαία: `private_sense = !private_sense;` (Αυτό φαίνεται να είναι λάθος στην υλοποίηση, καθώς η αντιστροφή της τοπικής σημαίας πρέπει να γίνει μόνο από το τελευταίο νήμα, αλλά εδώ γίνεται πάντα).
        - **Έλεγχος Ορίου**:
            - **Αν** το νήμα είναι το τελευταίο που έφτασε (`barrier->total_threads_barred == barrier->max_barred_threads`):
                - Μηδενίζει τον μετρητή (`total_threads_barred = 0`).
                - **Αντιστρέφει την καθολική σημαία** (`barrier->sense_flag = private_sense`) για να σηματοδοτήσει την απελευθέρωση όλων των νημάτων.
                - Ξεκλειδώνει το `mutex`.
            - **Αν** το νήμα **δεν** είναι το τελευταίο:
                - Ξεκλειδώνει το `mutex`.
                - Εισέρχεται σε **βρόχο αναμονής (Busy-wait)**: `while (barrier->sense_flag != private_sense);` – το νήμα παραμένει σε αυτόν τον βρόχο μέχρι το τελευταίο νήμα να αντιστρέψει την καθολική `sense_flag`.

- **srcBarrier\_destroy**:
    - Λειτουργία: Καταστρέφει το `mutex` του φραγμού (`pthread_mutex_destroy`). 

### Πειραματικά αποτελέσματα
- **N**: Το πλήθος των επαναλήψεων.
- Σε όλα τα παρακάτω αποτελέσματα οι χρόνοι είναι σε *seconds* και δίνεται ακρίβεια *microsecond*.
- Κάθε αποτέλεσμα πειράματος (δηλαδή εκτέλεσης με συγκεκριμένες εισόδους) είναι μέσος όρος 4 διαδοχικών εκτελέσεων.

#### Ερώτημα (i) - barrier_q1.c
Χρόνοι εκτέλεσης με συγκεκριμένο αριθμό threads και *N* επαναλήψεις στον βρόχο.
|N\Threads|**2**   |**4**   |**8**   |**16**  |**32**   |
|---------|--------|--------|--------|--------|---------|
|**1000** |0.011629|0.025473|0.054431|0.110857|0.222823 |
|**10000**|0.116384|0.264486|0.551713|1.095664|2.203366 |
|**50000**|0.575518|1.310204|2.755450|5.549380|11.144361|

#### Ερώτημα (ii) - barrier_q2.c
Χρόνοι εκτέλεσης με συγκεκριμένο αριθμό threads και *N* επαναλήψεις στον βρόχο.
|N\Threads|**2**   |**4**   |**8**   |**16**   |**32**   |
|---------|--------|--------|--------|---------|---------|
|**1000** |0.012146|0.040643|0.104397|0.212292 |0.398907 |
|**10000**|0.117764|0.408054|0.928869|1.984298 |4.049638 |
|**50000**|0.596483|2.039311|4.825920|10.192058|20.636920|

### Σχολιασμός αποτελεσμάτων
Από τους παραπάνω πίνακες συμπεραίνουμε τα εξής:
- Είναι φανερό από την χρήση μικρών *Ν*, ότι η χρήση οποιουδήποτε φράγματος δημιουργεί πολύ μεγάλη συνολική καθυστέρηση. Αυτό βέβαια είναι αναμενόμενο, αφού τα νήματα μπορεί να έχουν αυθαίρετα μεγάλες διαφορές στην ταχύτητα, και επομένως είναι σπάνιο οι ταχύτητές τους να έχουν αρκετά μικρή απόκλιση έτσι ώστε τα φράγματα να έχουν "αμελητέο" κόστος στην ταχύτητα.
- Και στις δύο υλοποιήσεις, οι χρόνοι αυξάνονται είτε όταν αυξάνονται τα νήματα, είτε όταν αυξάνεται το *N*. Αυτό είναι αναμενόμενο, αφού από την μία, με περισσότερα νήματα αυξάνεται η πιθανότητα κάποια να είναι πιο αργά και να υπάρχει περισσότερη αναμονή, ενώ από την άλλη, με μεγαλύτερο *Ν* αυξάνονται  το πλήθος των φραγμάτων που συναντώνται, και προφανώς και οι αναμονές.
- Όσον αφορά την επίδοση μεταξύ των  δύο πρώτων υλοποιήσεων, παρατηρούμε ότι η δεύτερη υλοποίηση είναι σε κάθε περίπτωση, λίγο έως πολύ πιο αργή από την πρώτη. Συγκεκριμένα, για λίγα νήματα και μικρό *Ν*, η διαφορές στους χρόνους είναι μικρές, ενώ για μεγάλα *Ν* και πολλά νήματα, η πρώτη υλοποίηση είναι ~2 φορές γρηγορότερη.
- Όταν ο αριθμός των νημάτων είναι μεγαλύτερος από αυτόν που υποστηρίζει το hardware (στο συγκεκριμένο σύστημα οι λογικοί πυρήνες είναι 16), η αύξηση του χρόνου εκτέλεσης συνεχίζεται. Σύμφωνα με τους παραπάνω πίνακες, αυτή η αύξηση (για 32 νήματα) έχει τον ίδιο ρυθμό με τις προηγούμενες. Αυτό ίσως συμβαίνει γιατί η καθυστέρηση του κάθε φράγματος μέχρι και τα 16 νήματα είναι συγκρίσιμη με αυτή που δημιουργείται όταν μερικά νήματα εκτελούνται χωρίς καμία χρονική επικάλυψη.

#### Ερώτημα (iii) - barrier_q3.c
Το πρόγραμμα δεν λειτουργεί σωστά, καθώς οδηγεί σε deadlock μετά την πρώτη "απενεργοποίηση" του barrier, μόλις φτάσει ο επιθυμητός αριθμός νημάτων. Ως αποτέλεσμα, δεν υπάρχουν πειραματικά δεδομένα για την συγκεκριμένη υλοποίηση.

Για τα πειράματα χρησιμοποιήθηκε σύστημα με τα εξής χαρακτηριστικά:
- **Μοντέλο laptop:** MSI Katana GF66 12UC
- **Μοντέλο CPU:** 12th Gen Intel(R) Core(TM) i7-12650H
- **Logical processors:** 16
- **OS:** WSL2 (Ubuntu) πάνω σε Windows11
- **C compiler:** gcc (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0

**Σημείωση:** Η hardware μνήμη RAM είναι 16GB όμως το WSL την περιορίζει σε ~8GB. Παρόλα αυτά **τονίζεται ότι το WSL δεν περιορίζει την χρήση των hardware threads**. 

Τα προγράμματα barrier_q1 και barrier_q2 εκτελούνται με σωστό τρόπο στα συστήματα linux του εργαστηρίου.
