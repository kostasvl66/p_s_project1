# Άσκηση 1.5

### Περιγραφή προβλήματος
Το πρόβλημα βρίσκεται στην σωστή υλοποίηση της λειτουργίας ενός φράγματος σε κάθε υποερώτημα, έτσι ώστε με συνεπή τρόπο, όλα τα νήματα να βρίσκονται πάντα στην ίδια επανάληψη του αντίστοιχου βρόχου.

### Περιγραφή λύσης
Και στα 3 ερωτήματα, έχουν οριστεί οι ακόλουθες βοηθητικές συναρτήσεις:
- `parse_args()`: Διαβάζει τα ορίσματα της εντολής με τους κατάλληλους ελέγχους και ενημερώνει τις global μεταβλητές.
- `elapsed()`: Επιστρέφει την χρονική διαφορά σε δευτερόλεπτα (έως ακρίβεια nsec) από το start στο end. Σημειώνεται ότι για τις χρονικές μετρήσεις χρησιμοποιείται η δομή struct timespec της *C11*.

Και στα τρία ερωτήματα ακολουθείται η ίδια δομή της `main()`, η οποία δημιουργεί και εκκινεί τα threads, αναθέτοντας στο καθένα την εκτέλεση της `loop_worker()`.

#### Ερώτημα (i) - barrier_q1.c
Για το πρώτο ερώτημα, γίνεται χρήση του ήδη υλοποιημένου φράγματος POSIX. Δηλαδή μέσα στο βρόχο του κάθε νήματος γίνεται απλώς η κλήση:
```c
// POSIX implementation of barrier wait
pthread_barrier_wait(&barrier);
```
Επίσης στην `main()` γίνεται ένα σχετικό `pthread_barrier_init()` και `pthread_barrier_destroy()`.

#### Ερώτημα (ii) - barrier_q2.c
Για το δεύτερο ερώτημα, όπως ζητείται και στην εκφώνηση χρησιμοποιείται η υλοποίηση φράγματος με mutex και μεταβλητή συνθήκης που έχει αναφερθεί στο μάθημα.

Ο κώδικας του φράγματος περικλείεται μέσα σε ένα mutex, έτσι ώστε να μόνο ένα νήμα την φορά ενημερώνει την κατάσταση του φράγματος. Χρησιμοποιείται μεταβλητή `waiting_thread_count`, η οποία μετρά τα νήματα που έχουν ήδη φτάσει το φράγμα και περιμένουν να προχωρήσουν. Αν ένα νήμα που εκτελεί τον κώδικα του φράγματος δεν βρει **όλα τα υπόλοιπα** να περιμένουν, τότε και αυτό πρέπει να περιμένει. Διαφορετικά, το τελευταίο νήμα που φτάνει στο φράγμα "ξυπνά" όλα τα υπόλοιπα νήματα, και όλα μαζί (ιδανικά) συνεχίζουν μετά το φράγμα.
